###Timetick

upd:
[Используем io.WriteString вместо fmt.Fprintf](https://github.com/audetv/backend-development-on-go/pull/3/commits/4a448b25960b8d7ac9d9c592432a9467506ca337#r721374417)

После изучения мануалов по net.conn, в общем то стало
понятно, что надо самому читать соединение и обработать
ошибку, чтобы выйти из горутины. Таким образом заменяем
`fmt.Fprintf(conn, "now: %s\n", t)`, мы не будем просто
писать напрямую время в conn с помощью Fprintf. Используем:
```
_, err := io.WriteString(conn, t.String()+"\r\n")
if err != nil {
return
}
```
Ирония в том, что WriteString был изначально
в примере методички. Теперь при закрытии консоли клиентом,
получим ошибку:

`write tcp [::1]:9000->[::1]:1459: wsasend: An existing connection was forcibly closed by the remote host.`

Теперь можно выйти из функции (горутины) и отработать 
отложенные вызовы. Закрыть соединение и передать в канал
leaving, что клиент разорвал соединение, закрыть соединение,
закрыть wait group

Теперь программа отрабатывает правильно, при сценариях 
выхода клиента и завершения работы сервера. Закрывается
листенер, ждем отработки всех вейт групп, в горутинах 
закрываются каналы и соединения.

```
2021/10/04 16:58:21 Im started!
2021/10/04 16:58:27 [::1]:19049 has arrived
2021/10/04 16:58:31 done
2021/10/04 16:58:31 [::1]:19049 has left
2021/10/04 16:58:31 exit
```
При определенных сценариях все еще можно получить
в лог сервера при выходе:

`accept tcp [::]:9000: use of closed network connection`

Я оставлю для истории свои рассуждения и комментарии ниже,
они не актуальны для последней версии кода. 

__________________________________
### Не актуально

upd: Не могу понять, как отправить событие leaving - покинуть канал и закрыть соединение. Если клиент закроет консоль, то я так понимаю, что сервер продолжает слать в соединение текущее время каждую секунду.

upd: при закрытии консоли клиента, соединение пропадает, во всяком случае в netstat -atulpn его нет

upd: я так понял, что горутина handleConnect продолжает
работу. Т.е go func() с бесконечным циклом работает,
слушает соединение, после установления соединения
запускает горутину handleConnect и дальше работает,
в ожидании через селект или завершения контекста, 
или нового соединения, и не получает никакой обратной 
связи в том случае, если клиент сам закроет соединение
со своей стороны.

upd: Вопросы с закрытием соединения после того,
как на сервере нажали ctrl+c 
- Надо ли закрывать conn через defer отложено после выхода
из handleConn?
Когда в main мы закрываем листенер, получаем в консоли: 
`accept tcp [::]:9000: use of closed network connection`
Это не зависит от того закрыли ли conn в handleConn или нет,
это нормально?
- Закрыть листенер в main, если уже закрыты все conn правильно? 
Независимо от того, закрыли или нет листенер,
получаем в нетстат (после ctrl+d сервера):

TCP | [::1]:1480 | [::1]:9000 | CLOSE_WAIT | 9832  
--- | -----------| ---------- |------------|----- 
TCP | [::1]:9000 | [::1]:1480 | FIN_WAIT_2 | 5232

Запись пропадает через 2 минуты, почему 2?
